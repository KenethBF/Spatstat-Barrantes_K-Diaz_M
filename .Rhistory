plot(d) # grafico de calor-densidad
d = density(x, 0.1) # segundo argumento es resolucion de densidad: sigma
plot(d)
Y= shapley
plot(density(Y, 0.01))
plot(carapa$y+carapa$x)
plot(carapa$y+carapa$x_rev)
plot(carapa$y+carapa$x_rev) # plot x corregidas
X <- ppp(carapa$x_rev, carapa$y, window = owin(c(0,400), c(0,400))) # dar formato de datos a coordenadas
DD = density(X)
plot(X)
plot(DD)
p <- ggplot(carapa, aes(x_rev, y)) +
geom_point() +
facet_wrap(carapa$Parc)
p
p <- ggplot(carapa, aes(x_rev, y)) +
geom_point() +
facet_wrap(carapa$Parc)
library(ggplot2)
# librerias
library(spatstat)
library(ggplot2)
carapa <- read.csv("Datos/Mapeamento_parcelas_corregido.csv", header = T, sep = ";", stringsAsFactors = TRUE)
head(carapa)
carapa$Parc <- as.factor(carapa$Parc)
carapa$Sub.P <- as.factor(carapa$Sub.P)
carapa$Prod. <- as.logical(carapa$Prod.)
str(carapa)
summary(carapa)
x = redwood # libreria de r
plot(x) # graficar libreria
d = density(x) # densidad de nube de puntos en rectangulo
plot(d) # grafico de calor-densidad
d = density(x, 0.1) # segundo argumento es resolucion de densidad: sigma
plot(d)
Y= shapley
plot(density(Y, 0.01))
plot(carapa$y+carapa$x) # plot x no corregidas
plot(carapa$y+carapa$x_rev) # plot x corregidas
X <- ppp(carapa$x_rev, carapa$y, window = owin(c(0,400), c(0,400))) # dar formato de datos a coordenadas
DD = density(X)
plot(X)
plot(DD)
library(ggplot2)
p <- ggplot(carapa, aes(x_rev, y)) +
geom_point() +
facet_wrap(carapa$Parc)
p
ggplot(carapa, aes(x_rev, y)) +
geom_contour(aes(z = density)) +
facet_wrap(carapa$Parc)
p <- ggplot(carapa, aes(x_rev, y)) +
geom_point() +
facet_wrap(carapa$Parc)
p
jp <- ggplot(carapa, aes(x_rev, y)) +
geom_raster(aes(fill = density)) +
facet_wrap(carapa$Parc)
jp
ggplot(carapa, aes(x_rev, y)) +
geom_contour(aes(z = density)) +
facet_wrap(carapa$Parc)
ggplot(carapa, aes(x_rev, y)) +
geom_raster(aes(fill = density)) +
facet_wrap(carapa$Parc)
# librerias
library(spatstat)
library(ggplot2)
carapa <- read.csv("Datos/Mapeamento_parcelas_corregido.csv", # cargar base de datos
header = T, # asignar títulos según primera columna
sep = ";", # separador de columnas
stringsAsFactors = TRUE)	# asignar columnas de caracteres como factores
head(carapa) # previsualizar datos
str(carapa)
p <- ggplot(carapa, aes(x_rev, y)) +
geom_point() +
facet_wrap(carapa$Parc)
p
ggplot(carapa, aes(x_rev, y)) +
geom_contour(aes(z = density)) +
facet_wrap(carapa$Parc)
X <- ppp(carapa$x_rev, carapa$y, window = owin(c(0,400), c(0,400))) # dar formato de datos a coordenadas
DD = density(X)
ggplot(carapa, aes(x_rev, y)) +
geom_contour(aes(z = density)) + X
ggplot(carapa, aes(x_rev, y)) +
geom_contour(aes(z = density)) +
scale_y_continuous(X) +
scale_x_continuous(X) +
facet_wrap(carapa$Parc)
ggplot(carapa, aes(x_rev, y)) +
geom_bin2d() +
facet_wrap(carapa$Parc)
ggplot(carapa, aes(x_rev, y)) +
geom_bin2d(bins = 70) +
facet_wrap(carapa$Parc)
ggplot(carapa, aes(x_rev, y)) +
geom_bin2d(bins = 70) +
scale_fill_continuous(type = "viridis") +
facet_wrap(carapa$Parc)
ggplot(carapa, aes(x_rev, y)) +
geom_hex() +
facet_wrap(carapa$Parc)
ggplot(carapa, aes(x_rev, y)) +
geom_hex() +
facet_wrap(carapa$Parc)
ggplot(carapa, aes(x_rev, y)) +
geom_density_2d() +
facet_wrap(carapa$Parc)
ggplot(carapa, aes(x_rev, y)) +
stat_density_2d() +
facet_wrap(carapa$Parc)
ggplot(carapa, aes(x_rev, y)) +
stat_density_2d() +
facet_wrap(carapa$Parc)
ggplot(carapa, aes(x_rev, y)) +
stat_density_2d(geom = "polygon") +
facet_wrap(carapa$Parc)
ggplot(carapa, aes(x_rev, y)) +
stat_density_2d() +
facet_wrap(carapa$Parc)
ggplot(carapa, aes(x_rev, y)) +
geom_density_2d() +
facet_wrap(carapa$Parc)
ggplot(carapa, aes(x_rev, y)) +
stat_density_2d(geom = "polygon", color = "white") +
facet_wrap(carapa$Parc)
ggplot(carapa, aes(x_rev, y)) +
stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
scale_x_continuous(expand = c(0, 400)) +
scale_y_continuous(expand = c(0, 400)) +
facet_wrap(carapa$Parc)
ggplot(carapa, aes(x_rev, y)) +
stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
facet_wrap(carapa$Parc)
p <- ggplot(carapa, aes(x_rev, y)) +
geom_point() +
facet_wrap(carapa$Parc)
p
dd <- ggplot(carapa, aes(x_rev, y)) +
stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
facet_wrap(carapa$Parc)
dd
dist_arb <- ggplot(carapa, aes(x_rev, y)) + # asignación de base de variables "x" y "y" a partir de coordenadas originales
geom_point() + # asignación de puntos en gráfico
facet_wrap(carapa$Parc) # crea gráficos por parcela
dist_arb
dist_arb <- ggplot(carapa, aes(x, y)) + # asignación de base de variables "x" y "y" a partir de coordenadas corregidas
geom_point() + # asignación de puntos en gráfico
facet_wrap(carapa$Parc) # crea gráficos por parcela
dist_arb
dist_arb1 <- ggplot(carapa, aes(x_rev, y)) + # asignación de base de variables "x" y "y" a partir de coordenadas corregidas
geom_point() + # asignación de puntos en gráfico
facet_wrap(carapa$Parc) # crea gráficos por parcela
dist_arb1
dd <- ggplot(carapa, aes(x, y)) +
stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
facet_wrap(carapa$Parc)
dd
dist_arb <- ggplot(carapa, aes(x, y)) + # asignación de base de variables "x" y "y" a partir de coordenadas corregidas
geom_point() + # asignación de puntos en gráfico
facet_wrap(carapa$Parc) # crea gráficos por parcela
dist_arb
dist_arb1 <- ggplot(carapa, aes(x_rev, y)) + # asignación de base de variables "x" y "y" a partir de coordenadas corregidas
geom_point() + # asignación de puntos en gráfico
facet_wrap(carapa$Parc) # crea gráficos por parcela
dist_arb1
dd <- ggplot(carapa, aes(x_rev, y)) +
stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
facet_wrap(carapa$Parc)
dd
# Las 4 parcelas
coord <- ppp(carapa$x_rev, carapa$y, window = owin(c(0,400), c(0,400)))
coord
K <- Kest(coord)
K
plot(K)
# parcela 1
carapa1 <- carapa[carapa$Parc == "1", ]
head(as.data.frame(K))
# parcela 1
carapa1 <- carapa[carapa$Parc == "1", ]
coord1 <- ppp(carapa1$x_rev, carapa1$y, window = owin(c(0,400), c(0,400)))
# parcela 1
carapa1 <- carapa[carapa$Parc == "1", ]
coord1 <- ppp(carapa1$x_rev, carapa1$y, window = owin(c(0,400), c(0,400)))
View(coord1)
K1 <- Kest(coord1)
K1
plot(K1)
# parcela 1
tod_1 <- carapa[carapa$Parc == "1", ]
K_tod_1 <- Kest(tod_1_coor)
tod_1_coor <- ppp(tod_1$x_rev, tod_1$y, window = owin(c(0,400), c(0,400)))
K_tod_1 <- Kest(tod_1_coor)
K1
K_tod_1
summary(K_tod_1)
plot(K_tod_1)
plot(K_tod_1)
head(as.data.frame(K_tod_1))
K_tod_tod # descripción data frame función Kest
K_tod_tod <- Kest(coord) # función calculo Ripleys K
######### librerias ##########
library(spatstat)
library(ggplot2)
# Las 4 parcelas
coord <- ppp(carapa$x_rev, carapa$y, # asignación de formato espacial a columnas coordenadas
window = owin(c(0,400), c(0,400))) # escala espacial x, y
K_tod_tod <- Kest(coord) # función calculo Ripleys K
K_tod_tod # descripción data frame función Kest
# Las 4 parcelas
coord <- ppp(carapa$x_rev, carapa$y, # asignación de formato espacial a columnas coordenadas
window = owin(c(0,400), c(0,400))) # escala espacial x, y
K_tod_tod <- Kest(coord) # función calculo Ripleys K
K_tod_tod # descripción data frame función Kest
plot(K_tod_tod) # graficación función y estimados Ripleys K
head(as.data.frame(K_tod_tod)) # previsualización de estimados
E <- envelope(coord, Kest, nsim=100)
plot(E)
E <- envelope(coord, Kest, nsim=1000)
plot(E)
E1 <- envelope(tod_1_coor, # base de datos espacial
Kest, # función cálculo Ripleys K
nsim=1000) # generación de puntos siguiendo patrón aleatorio a partir de Kpois(theo)
plot(E1)
install.packages("geoR")
library(geoR)
View(carapa)
datgeo <- as.geodata(carapa, coords.col = 4:5, data.col = 10)
plot(datgeo)
str(carapa) # estructura de base de datos
datgeo <- as.geodata(tod_1, coords.col = 4:5, data.col = 10)
plot(datgeo)
# parcela 1
tod_1 <- carapa[carapa$Parc == "1", ]
tod_1
View(tod_1)
datgeo <- as.geodata(tod_1, coords.col = 4:5, data.col = 10)
plot(datgeo)
datgeo <- as.geodata(tod_1, coords.col = 4:5)
plot(datgeo)
datgeo <- as.geodata(tod_1, coords.col = 5:4)
plot(datgeo)
datgeo <- as.geodata(tod_1, coords.col = 4:5)
datgeo
datgeo
head(datgeo)
datgeo <- as.geodata(tod_1, coords.col = 4:5, data.col = 10)
head(datgeo)
View(datgeo)
######### librerias ##########
library(spatstat)
library(ggplot2)
####### Cargar y dar formato a datos ##########
carapa <- read.csv("Datos/Mapeamento_parcelas_corregido.csv", # cargar base de datos
header = T, # asignar títulos según primera columna
sep = ";", # separador de columnas
stringsAsFactors = TRUE)	# asignar columnas de caracteres como factores
library(geoR)
# parcela 1
tod_1 <- carapa[carapa$Parc == "1", ]
datgeo <- as.geodata(tod_1, coords.col = 4:5, data.col = 10)
plot(datgeo)
str(tod_1)
####### Cargar y dar formato a datos ##########
carapa <- read.csv("Datos/Mapeamento_parcelas_corregido.csv", # cargar base de datos
header = T, # asignar títulos según primera columna
sep = ";")	# asignar columnas de caracteres como factores
tod_1_coor <- ppp(tod_1$x_rev, tod_1$y, window = owin(c(0,400), c(0,400)))
# parcela 1
tod_1 <- carapa[carapa$Parc == "1", ]
datgeo <- as.geodata(tod_1, coords.col = 4:5, data.col = 10)
plot(datgeo)
######### librerias ##########
library(spatstat)
library(ggplot2)
####### Cargar y dar formato a datos ##########
carapa <- read.csv("Datos/Mapeamento_parcelas_corregido.csv", # cargar base de datos
header = T, # asignar títulos según primera columna
sep = ";", # separador de columnas
stringsAsFactors = TRUE)	# asignar columnas de caracteres como factores
carapa$Parc <- as.factor(carapa$Parc) # transformar "Parcelas" de entero a factor
carapa$Sub.P <- as.factor(carapa$Sub.P) # transformar "Subparcela" de entero a factor
carapa$Prod. <- as.logical(carapa$Prod.) # transformar "Producción de fruto" de entero a lógico
str(carapa) # estructura de base de datos
head(carapa) # previsualizar datos
# Las 4 parcelas
coord <- ppp(carapa$x_rev, carapa$y, # asignación de formato espacial a columnas coordenadas
window = owin(c(0,400), c(0,400))) # escala espacial x, y
K_tod_tod <- Kest(coord) # función calculo Ripleys K
K_tod_tod # descripción data frame función Kest
plot(K_tod_tod) # graficación función y estimados Ripleys K
head(as.data.frame(K_tod_tod)) # previsualización de estimados
E <- envelope(coord, # base de datos espacial
Kest, # función cálculo Ripleys K
nsim=1000) # generación de puntos siguiendo patrón aleatorio a partir de Kpois(theo)
plot(E)
library(geoR)
datgeo <- as.geodata(tod_1, coords.col = 4:5, data.col = 10)
head(datgeo)
plot(datgeo)
dist_arb2 <- ggplot(carapa, aes(x_rev, y, size = DAP) + # asignación de base de variables "x" y "y" a partir de coordenadas corregidas
dist_arb2 <- ggplot(carapa, aes(x_rev, y, size = DAP)) + # asignación de base de variables "x" y "y" a partir de coordenadas corregidas
geom_point() + # asignación de puntos en gráfico
facet_wrap(carapa$Parc) # crea gráficos por parcela
dist_arb2
####### Graficos exploratorios ############
X <- ppp(carapa$x_rev, carapa$y, window = owin(c(0,400), c(0,400))) # dar formato de datos a coordenadas (no necesario al momento)
plot(quadratcount(X))
quadrat.test(X)
quadrat.test(X, nx= 10) # prueba de cuadrados para distribución
plot(quadratcount(X), nx= 10) # dividido en cuadriculas, cuantos puntos tiene cada cuadricula
quadrat.test(X, nx= 10) # prueba de cuadrados para distribución
plot(quadratcount(X, nx= 10)) # dividido en cuadriculas, cuantos puntos tiene cada cuadricula
quadrat.test(X, nx= 10) # prueba de cuadrados para distribución
E <- envelope(coord, # base de datos espacial
Kest, # función cálculo Ripleys K
nsim=1000) # generación de puntos siguiendo patrón aleatorio a partir de Kpois(theo)
plot(E)
######### librerias ##########
library(spatstat)
library(ggplot2)
####### Cargar y dar formato a datos ##########
carapa <- read.csv("Datos/Mapeamento_parcelas_corregido.csv", # cargar base de datos
header = T, # asignar títulos según primera columna
sep = ";", # separador de columnas
stringsAsFactors = TRUE)	# asignar columnas de caracteres como factores
carapa$Parc <- as.factor(carapa$Parc) # transformar "Parcelas" de entero a factor
carapa$Sub.P <- as.factor(carapa$Sub.P) # transformar "Subparcela" de entero a factor
carapa$Prod. <- as.logical(carapa$Prod.) # transformar "Producción de fruto" de entero a lógico
str(carapa) # estructura de base de datos
head(carapa) # previsualizar datos
dist_arb <- ggplot(carapa, aes(x, y)) + # asignación de base de variables "x" y "y" a partir de coordenadas originales
geom_point() + # asignación de puntos en gráfico
facet_wrap(carapa$Parc) # crea gráficos por parcela
dist_arb
dist_arb1 <- ggplot(carapa, aes(x_rev, y)) + # asignación de base de variables "x" y "y" a partir de coordenadas corregidas
geom_point() + # asignación de puntos en gráfico
facet_wrap(carapa$Parc) # crea gráficos por parcela
dist_arb1
dist_arb2 <- ggplot(carapa, aes(x_rev, y, size = DAP)) + # asignación de base de variables "x" y "y" a partir de coordenadas corregidas
geom_point() + # asignación de puntos en gráfico
facet_wrap(carapa$Parc) # crea gráficos por parcela
dist_arb2
dens_arb <- ggplot(carapa, aes(x_rev, y)) + # asignación de base de variables "x" y "y" a partir de coordenadas
stat_density_2d(aes(fill = ..density..), # capa densidad de puntos
geom = "raster", # geometría raster
contour = FALSE) + # eliminación de contornos en puntos
facet_wrap(carapa$Parc) # crea gráficos por parcela
dens_arb
plot(quadratcount(X, nx= 10)) # dividido en cuadriculas, cuantos puntos tiene cada cuadricula
parc1 <- adultos[adultos$Parc == "1", ] # subconjunto adultos de parcela 1
parc1_coor <- ppp(parc1$x_rev, # coordenadas en x
parc1$y, # coordenadas en y
window = owin(c(0,400), # delimitación coordenadas x
c(0,400))) # delimitación coordenadas y
parc1 <- adultos[adultos$Parc == "1", ] # subconjunto adultos de parcela 1
carapa <- read.csv(".Datos/Mapeamento_parcelas_corregido.csv", # cargar base de datos
header = T, # asignar títulos según primera columna
sep = ";", # separador de columnas
stringsAsFactors = TRUE)	# asignar columnas de caracteres como factores
carapa <- read.csv("..Datos/Mapeamento_parcelas_corregido.csv", # cargar base de datos
header = T, # asignar títulos según primera columna
sep = ";", # separador de columnas
stringsAsFactors = TRUE)	# asignar columnas de caracteres como factores
carapa <- read.csv("Datos/Mapeamento_parcelas_corregido.csv", # cargar base de datos
header = T, # asignar títulos según primera columna
sep = ";", # separador de columnas
stringsAsFactors = TRUE)	# asignar columnas de caracteres como factores
carapa <- read.csv("..Datos/Mapeamento_parcelas_corregido.csv", # cargar base de datos
header = T, # asignar títulos según primera columna
sep = ";", # separador de columnas
stringsAsFactors = TRUE)	# asignar columnas de caracteres como factores
carapa <- read.csv("../Datos/Mapeamento_parcelas_corregido.csv", # cargar base de datos
header = T, # asignar títulos según primera columna
sep = ";", # separador de columnas
stringsAsFactors = TRUE)	# asignar columnas de caracteres como factores
carapa <- read.csv("../Datos/Mapeamento_parcelas_corregido.csv", # cargar base de datos
header = T, # asignar títulos según primera columna
sep = ";", # separador de columnas
stringsAsFactors = TRUE)	# asignar columnas de caracteres como factores
carapa$Parc <- as.factor(carapa$Parc) # transformar "Parcelas" de entero a factor
carapa$Sub.P <- as.factor(carapa$Sub.P) # transformar "Subparcela" de entero a factor
carapa$Prod. <- as.logical(carapa$Prod.) # transformar "Producción de fruto" de entero a lógico
str(carapa) # estructura de base de datos
head(carapa) # previsualizar datos
disp_arb <- ggplot(carapa, aes(x_rev, y)) + # asignación de base de variables "x" y "y" a partir de coordenadas x corregidas
geom_point() + # asignación de puntos en gráfico
facet_wrap(carapa$Parc) # crea gráficos por parcela
library(spatstat)
library(spatstat)
library(ggplot2)
disp_arb <- ggplot(carapa, aes(x_rev, y)) + # asignación de base de variables "x" y "y" a partir de coordenadas x corregidas
geom_point() + # asignación de puntos en gráfico
facet_wrap(carapa$Parc) # crea gráficos por parcela
disp_arb
dens_arb <- ggplot(carapa, aes(x_rev, y)) + # asignación de base de variables "x" y "y" a partir de coordenadas
stat_density_2d(aes(fill = after_stat(density)), # capa densidad de puntos
geom = "raster", # geometría raster
contour = FALSE) + # eliminación de contornos en puntos
facet_wrap(carapa$Parc) # crea gráficos por parcela
dens_arb
adultos <- carapa[carapa$DAP > "20", ] # subconjunto de individuos adultos
head(adultos)
parc1 <- adultos[adultos$Parc == "1", ] # subconjunto adultos de parcela 1
parc1_coor <- ppp(parc1$x_rev, # coordenadas en x
parc1$y, # coordenadas en y
window = owin(c(0,400), # delimitación coordenadas x
c(0,400))) # delimitación coordenadas y
K1 <- Kest(parc1_coor) # Kest= función para estimadores Ripley´s K
K1 # detalles de estimadores de función
plot(K1) # graficación de estimadores
head(as.data.frame(K1)) # previsualización de datos gráfico K1
# Parcela 2
parc2 <- adultos[adultos$Parc == "2", ]
parc2_coor <- ppp(parc2$x_rev,
parc2$y,
window = owin(c(0,400),
c(0,400)))
K2 <- Kest(parc2_coor)
plot(K2)
E1 <- envelope(parc1_coor, # base de datos espacial
Kest, # función cálculo Ripleys K
nsim=1000) # generación de puntos siguiendo patrón aleatorio a partir de Kpois(theo)
E1 <- envelope(parc1_coor, # base de datos espacial
Kest, # función cálculo Ripleys K
nsim=1000) # generación de puntos siguiendo patrón aleatorio a partir de Kpois(theo)
plot(E1)
E2 <- envelope(parc2_coor, # base de datos espacial
Kest, # función cálculo Ripleys K
nsim=1000) # generación de puntos siguiendo patrón aleatorio a partir de Kpois(theo)
E2.1 <- envelope(parc2_coor, # base de datos espacial
Kest, # función cálculo Ripleys K
nsim=100) # generación de puntos siguiendo patrón aleatorio a partir de Kpois(theo)
E2.1 <- envelope(parc2_coor, # base de datos espacial
Kest, # función cálculo Ripleys K
nsim=100) # generación de puntos siguiendo patrón aleatorio a partir de Kpois(theo)
E2.2 <- envelope(parc2_coor, # base de datos espacial
Kest, # función cálculo Ripleys K
nsim=10) # generación de puntos siguiendo patrón aleatorio a partir de Kpois(theo)
plot(E2)
plot(E2.1)
plot(E2.2)
L <- sqrt(K1/pi)
plot(L)
plot(Gest(parc1_coor))
plot(K1, . - theo ~ r)
L <- sqrt(K1/pi, - theo ~ r)
L <- sqrt(K1/pi)
plot(L, . - theo ~ r)
E3 <- envelope(parc2_coor, # base de datos espacial
sqrt(K1/pi), # función cálculo Ripleys K
nsim=1000) # generación de puntos siguiendo patrón aleatorio a partir de Kpois(theo)
A2 <- envelope(A1, global=TRUE, nsim=19, transform=expression(sqrt(./pi)))
A2 <- envelope(parc1_coor, global=TRUE, nsim=19, transform=expression(sqrt(./pi)))
plot(A2)
plot(A2, . - theo ~ r)
A2 <- envelope(parc1_coor, global=TRUE, nsim=10, transform=expression(sqrt(./pi)))
plot(A2, . - theo ~ r)
plot(A2, . - theo ~ r, legend = FALSE)
plot(A2, . - theo ~ r, legend = FALSE)
A2 <- envelope(parc1_coor, global=FALSE, nsim=10, transform=expression(sqrt(./pi)))
plot(A2, . - theo ~ r)
plot(A2, . - theo ~ r, legend = FALSE)
plot(A2, . - theo ~ r)
View(carapa)
aa <- plot(Gest(parc1_coor)) # vecino más cercano
aa
head(as.data.frame(aa))
aa
head(as.data.frame(aa))
plot(density(parc1_coor))
plot(quadratcount(parc1_coor))
plot(quadratcount(parc1_coor, nx = 10))
quadrat.test(parc1_coor)
quadrat.test(parc1_coor, nx = 10)
quadrat.test(parc1_coor, nx = 8)
quadrat.test(parc1_coor, nx = 7)
plot(quadratcount(parc1_coor, nx = 5))
quadrat.test(parc1_coor, nx = 7)
quadrat.test(parc1_coor, nx = 6)
quadrat.test(parc1_coor, nx = 5)
quadrat.test(parc1_coor, nx = 6)
quadrat.test(parc1_coor, nx = 7)
quadrat.test(parc1_coor, nx = 5)
quadrat.test(parc1_coor, nx = 6)
quadrat.test(parc1_coor, nx = 7)
quadrat.test(parc1_coor, nx = 5)
quadrat.test(parc2_coor, nx = 5)
parc3 <- adultos[adultos$Parc == "3", ]
parc3_coor <- ppp(parc3$x_rev,
parc3$y,
window = owin(c(0,400),
c(0,400)))
quadrat.test(parc3_coor, nx = 5)
parc4 <- adultos[adultos$Parc == "4", ]
parc4_coor <- ppp(parc4$x_rev,
parc4$y,
window = owin(c(0,400),
c(0,400)))
quadrat.test(parc4_coor, nx = 5)
clarkevans.test(parc4_coor, correction = "donnelly")
clarkevans.test(parc1_coor, correction = "donnelly")
clarkevans.test(parc2_coor, correction = "donnelly")
plot(K1, . - theo ~ r)
L <- sqrt(K1/pi)
plot(L, . - theo ~ r)
A2 <- envelope(parc1_coor, global=FALSE, nsim=10, transform=expression(sqrt(./pi)))
plot(A2, . - theo ~ r)
plot(A2, . - theo ~ r, legend = FALSE)
