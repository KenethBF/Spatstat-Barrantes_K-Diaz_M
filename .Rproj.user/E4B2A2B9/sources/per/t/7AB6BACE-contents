---
title: "Tarea 5"
author: "Kenneth Barrantes"
date: "`r Sys.Date()`"
output:
  rmdformats::material
---

# Preparar archivos

Sección con código respectivo: - Dirección relativa correspondiente a documentos dentro de .Rproj - Vector con asignación de nombres y dirección de archivos .txt

```{r}

directorio <- "../data/bucles" # directorio relativo a carpeta contenedora de archivos


archivos_txt <- # vector lista de archivos
  list.files(
    path = directorio, # dirección de busqueda archivos
    full.names = TRUE, # asignación del nombre completo (archivo + directorio)
    pattern = "TXT$" # lectura archivos formato .txt
  )

```

```{r}
length(archivos_txt) # comprobación de vector
```

# Ejercicios

## Sección 1:

Haga un bucle `for` que una todos los datos contenidos en los archivos de texto en un solo cuadro de datos ('data frame', debe llamarse 'datos_camaras') y añada una columna con el nombre del archivo de donde provienen los datos (debe llamarse 'archivo') *Pistas:* 1) añadir el nombre del archivo en una columna se hace en el cuerpo del bucle luego de leer el archivo; 2) recuerden usar `basename())`.

```{r}
datos_camaras <- NULL # creación de data frame vacío

for (i in archivos_txt) {
  txt <- read.table(i, header = TRUE, skip = 4, sep = "\t") # leer archivo
  archivo <- basename(i) # objeto con nombre de archivo
  datos <- data.frame(archivo, txt) # dataframe con datos de archivo y asignación nombre archivo
  datos_camaras <- rbind(datos_camaras, datos) # adición de datos de cada archivo a datos_camara en bucle

}

DT::datatable(datos_camaras, options = list(pageLength = 3)) # previsualización de datos

```

## Sección 2:

Haga un bucle `sapply` que devuelva el número de familias para cada archivo. El bucle debe usar los datos en el data frame 'datos_camaras' creado en el ejercicio 1 (no debe leer de nuevo los archivos de texto). El resultado debe ser guardado en un cuadro de datos ('data frame') que contenga las columnas 'archivo' y 'n_familias'. Pistas: 1) necesitan crear una función en la llamada del bucle; 2) el bucle debe ciclar sobre cada uno de los nombres de archivo; 3) deben crear un subconjunto de los datos para cada archivo a lo interno del bucle.


```{r}
n_familias <- sapply(X = unique(datos_camaras$archivo), FUN = function(i) { # ciclo asignado para lectura unica por nombre de archivo
    
    data_cam <- datos_camaras[datos_camaras$archivo == i, ] # subset de datos para i nombre de archivo
    familia <- length(unique(data_cam$Family)) # numero familias de i nombre de archivo
    
    return(familia) # variable resultado de funcion
    }
       )

archivo <- unique(datos_camaras$archivo) # nombre de archivos

df <- data.frame(archivo, n_familias) # crea data.frame con "archivo" y "n_familias" 
DT::datatable(df, options = list(pageLength = 3)) # previsualización de datos

```

## Sección 3:
Haga un bucle `sapply` que devuelva el número de géneros (columna "genus") para cada archivo. El bucle debe usar los datos en el data frame ‘datos_camaras’ creado en el ejercicio 1 (no debe leer de nuevo los archivos de texto). El resultado debe ser añadido como una nueva columna al cuadro de datos creado en el ejercicio 2.


```{r}
n_generos <- sapply(X = unique(datos_camaras$archivo), FUN = function(i) { # ciclo asignado para lectura unica por nombre de archivo
    
    data_cam <- datos_camaras[datos_camaras$archivo == i, ] # subset de datos para i nombre de archivo
    n_gen <- length(unique(data_cam$Genus)) # numero generos en i nombre de archivo
    
    return(n_gen) # variable respuesta de función
    }
       )

df <- data.frame(df, n_generos) # agrega columna "n_generos" a data frame
DT::datatable(df, options = list(pageLength = 3)) # previsualización de datos

```

## Sección 4:
Haga un bucle `sapply` que devuelva la fecha de creación del video para cada archivo. El bucle debe usar los datos en el data frame ‘datos_camaras’ creado en el ejercicio 1 (no debe leer de nuevo los archivos de texto). El resultado debe ser añadido como una nueva columna al cuadro de datos creado en el ejercicio 2.


```{r}
date <- sapply(X = unique(datos_camaras$archivo), FUN = function(i) { # ciclo asignado para lectura unica por nombre de archivo
    
    data_cam <- datos_camaras[datos_camaras$archivo == i, ] # subset de datos para i nombre de archivo
    fecha <- unique(data_cam$Date) # fecha en que se creó cada archivo
    
    return(fecha) # variable respuesta de función
    }
       )

df <- data.frame(df, date) # agrega columna "fecha"
DT::datatable(df, options = list(pageLength = 3)) # previsualización de datos

```

## Sección 5:
Haga un bucle `sapply` que calcule el número de veces que se observó cada especie. El bucle debe trabajar sobre el data frame ‘datos_camaras’ creado en el ejercicio 1 (no debe leer de nuevo los archivos de texto) y el cálculo debe ser la suma de la columna ‘MaxN’. Ponga los resultados en un cuadro de datos con columnas para especie y número de observaciones. (pista: `unique(datos_camaras$Species)`). Remueva el campo en el que especie es igual a ““.

```{r}
spp <- unique(datos_camaras$Species) # listado de especies presentes en datos_camaras
spp <- spp[-1] # limpieza de listado de especies, eliminación de entradas ""

n_obs <- sapply(X = spp, FUN = function(i) { # ciclo asignado para lectura de listado de especies
    data_cam <- datos_camaras[datos_camaras$Species == i, ] # subset de datos para i especie en archivo datos_camaras
    obs <- sum(data_cam$MaxN) # suma de numero de observaciones máximo por especie

    return(obs) # variable respuesta de función
    }
       )

ds <- data.frame(spp, n_obs) # creación de data frame con columnas "spp" y "n_obs"
DT::datatable(ds, options = list(pageLength = 3)) # previsualización de datos

```


## Sección 6:

Utilice bucles `sapply` para añadir el mínimo y máximo de la profundidad para cada una de las especies en el cuadro de datos creado en el ejercicio anterior (pistas: 1) asegúrese que la columna de profundidad es numérica antes de calcular las profundidades; 2) `gsub(" m", "", vector)`; 3) `gsub(",", ".", vector)`; 4) `as.numeric()`)

```{r}
library(purrr) # cargar librería purrr

datos_camaras[9] <- map_df(datos_camaras[9], ~ gsub(" m", "", .x)) # limpieza de errores y diferencias en digitación
datos_camaras[9] <- map_df(datos_camaras[9], ~ gsub(",", ".", .x)) # limpieza de errores y diferencias en digitación
datos_camaras$Depth <- as.numeric(datos_camaras$Depth) # convertir columna Depth de caráracter a numérica

min_prof <- sapply(X = spp, FUN = function(i) { # ciclo asignado para de especies
    
    data_cams <- datos_camaras[datos_camaras$Species == i, ] # subset de datos para i nombre de especie
    
    mini_prof <- min(data_cams$Depth) # profundida mínima a la que se encontró i especie

    return(mini_prof) # variable respuesta de función
    }
       )

ds <- data.frame(ds, min_prof) # se agrega columna "min_prof" a data frame
DT::datatable(ds, options = list(pageLength = 3)) # previsualización de datos

```


```{r}

max_prof <- sapply(X = spp, FUN = function(i) { # ciclo asignado para de especies
    
    data_cams <- datos_camaras[datos_camaras$Species == i, ] # subset de datos para i nombre de especie
        
    maxi_prof <- max(data_cams$Depth) # profundida máxima a la que se encontró i especie
    
    return(maxi_prof)  # variable respuesta de función
    }
       )

ds <- data.frame(ds, max_prof) # se agrega columna "max_prof" a data frame
DT::datatable(ds, options = list(pageLength = 3))  # previsualización de datos

```

## Sección 7:
Calcule el rango de profundidad (i.e. la diferencia entre el mínimo y el máximo de la profundidad) para cada especie y añádalo como una columna al cuadro de datos creado en el ejercicio 5

```{r}

rango <- sapply(X = spp, FUN = function(i) { # ciclo asignado para de especies
    
    data_cams <- datos_camaras[datos_camaras$Species == i, ] # subset de datos para i nombre de especie
    
    rang <- abs(max(data_cams$Depth) - min(data_cams$Depth)) # calculo de rango de profundidad a la que se encontró cada especie (máxima profundida - mínima profundidad)
    return(rang)
    }
       )

ds <- data.frame(ds, rango) # se agrega columna "max_prof" a data frame
ds$rango <- round(ds$rango, 2) # redondeo de valores en columna "rango" a dos decimales

DT::datatable(ds, options = list(pageLength = 3)) # previsualización de datos


```

## Sección 8: 
Incluya el cuadro de datos generado en los ejercicios 5 a 7 como una tabla en su reporte usando la función `DT` del paquete `datatable`.
```{r}

DT::datatable(ds) # previsualización conjunto de datos emplenado paquete "datatable"
```

## Sección 9:
Publique el reporte en [Rpubs](https://rpubs.com/) y añada el enlace en el reporte (use un enlace en el texto)

Disponible al dar click [aquí](poner enlace)

## Información de la sesión

```{r session, echo=FALSE}
sessionInfo() # Información de la sesión
```
